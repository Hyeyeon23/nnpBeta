/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 PACK1000_WOOD.gltf 
*/

import React, { useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { TextureLoader, Color, SRGBColorSpace } from "three";
import * as THREE from "three";
import { useCustomGLTF } from "../../hooks/useCustomGLTF";

export function CAN200({ imageSrc, color1, ...props }) {
  const { scene, nodes, materials } = useCustomGLTF("CAN200.glb");
  const loader = new THREE.TextureLoader();

  // 외부 기본 캔버스 바닥에 맞게 물체 위치 상하 조절
  scene.position.y = 0.3;

  /* 그림자 받기 */
  if (scene) {
    // scene이 존재하는 경우, scene 내의 모든 메쉬들에 castShadow 적용
    scene.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true; // 그림자 생성
        child.receiveShadow = true; // 그림자 받기
        // 이상하게 귀퉁이에 음영지는 현상 제거용 (export시 무슨 smooth 설정이 잘못되서 생긴 현상이라 재계산을 해줘야 하는 원리라고 한다. )
        child.geometry.computeVertexNormals();

        child.material.metalness = 0.1;
        child.material.roughness = 0.9; // 매트하게
        child.material.emissive = new THREE.Color(0x111111); // 아주 약한 자체 발광
        child.material.envMapIntensity = 0.3; // 환경광 반응 낮춤
      }
    });
  }

  /* 사진 설정 있는 객체 조회 (단 한번 실행) */
  const targetMeshes = [];
  scene.traverse((child) => {
    //console.log("child = ", child);
    console.log("[[search]] child.material = ", child.material);
    if (
      child.isMesh &&
      child.material &&
      child.material.map &&
      child.material.map.name === "마캐캔전개도"
    ) {
      targetMeshes.push(child);
    }
  });

  /* 이미지 변경 */
  // 텍스쳐 이름을 바탕으로 텍스쳐를 찾아서 교체하는 함수
  const updateTexture = (textureName, imageSrc) => {
    loader.load(imageSrc, (newTexture) => {
      targetMeshes.forEach((child) => {
        const map = child.material.map;

        // 설정들 복사
        newTexture.encoding = map.encoding;
        newTexture.wrapS = map.wrapS;
        newTexture.wrapT = map.wrapT;
        newTexture.repeat.copy(map.repeat);
        newTexture.offset.copy(map.offset);
        newTexture.anisotropy = map.anisotropy;
        newTexture.flipY = map.flipY;
        newTexture.center.copy(map.center);
        newTexture.colorSpace = "srgb";

        newTexture.anisotropy = Math.min(map.anisotropy, 4);

        // 새 텍스쳐로 교체해준 다음에도 계속 같은 이름 값으로 찾을 수 있게
        newTexture.name = textureName;
        child.material.map = newTexture;
        child.material.needsUpdate = true;
      });
    });
  };

  useEffect(() => {
    if (imageSrc !== "/sample.png") {
      console.log("new image upload");
      updateTexture("마캐캔전개도", imageSrc);
    }

    if (color1) {
      // 뚜껑
      if (materials["매테리얼.002"]) {
        materials["매테리얼.002"].color = new Color(color1);
        materials["매테리얼.002"].needsUpdate = true;
      }
    }
  }, [imageSrc, nodes, color1, materials]); // imageSrc 또는 nodes가 변경될 때마다 텍스쳐 업데이트

  return <primitive object={scene} {...props} castShadow />;
}

useGLTF.preload("/CAN200.glb");
